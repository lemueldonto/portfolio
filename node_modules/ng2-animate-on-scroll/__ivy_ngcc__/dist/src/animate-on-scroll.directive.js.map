{"version":3,"file":"animate-on-scroll.directive.js","sources":["animate-on-scroll.directive.js"],"names":[],"mappings":"AAAA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAIO;AACP;;;;;;;;;;;;oBAAiC;AACjC;AACA;AACA;AACA","sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = require(\"@angular/core\");\nvar scroll_service_1 = require(\"./scroll.service\");\nvar rxjs_1 = require(\"rxjs\");\nvar AnimateOnScrollDirective = /** @class */ (function () {\n    function AnimateOnScrollDirective(elementRef, renderer, scroll) {\n        this.elementRef = elementRef;\n        this.renderer = renderer;\n        this.scroll = scroll;\n        this.scrollSub = new rxjs_1.Subscription();\n        this.resizeSub = new rxjs_1.Subscription();\n        // Pixel offset from screen bottom to the animated element to determine the start of the animation\n        this.offset = 80;\n    }\n    Object.defineProperty(AnimateOnScrollDirective.prototype, \"id\", {\n        get: function () {\n            return this.elementRef.nativeElement.id;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AnimateOnScrollDirective.prototype.ngOnInit = function () {\n        var _this = this;\n        if (!this.animationName) {\n            throw new Error('animationName required');\n        }\n        // default visibility to false\n        this.isVisible = false;\n        // subscribe to scroll event using service\n        this.scrollSub = this.scroll.scrollObs\n            .subscribe(function () { return _this.manageVisibility(); });\n        // subscribe to resize event using service so scrolling position is always accurate\n        this.resizeSub = this.scroll.resizeObs\n            .subscribe(function () { return _this.manageVisibility(); });\n    };\n    AnimateOnScrollDirective.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        // run visibility check initially in case the element is already visible in viewport\n        setTimeout(function () { return _this.manageVisibility(); }, 1);\n    };\n    AnimateOnScrollDirective.prototype.ngOnDestroy = function () {\n        this.scrollSub.unsubscribe();\n        this.resizeSub.unsubscribe();\n    };\n    /**\n     * check for visibility of element in viewport to add animation\n     *\n     * @returns void\n     */\n    AnimateOnScrollDirective.prototype.manageVisibility = function () {\n        if (this.isVisible) {\n            // Optimisation; nothing to do if class has already been applied\n            return;\n        }\n        // check for window height, may change with a window resize\n        this.getWinHeight();\n        // get vertical position for selected element\n        this.getOffsetTop();\n        // we should trigger the addition of the animation class a little after getting to the element\n        var scrollTrigger = this.offsetTop + this.offset - this.winHeight;\n        // using values updated in service\n        if (this.scroll.pos >= scrollTrigger) {\n            this.addAnimationClass();\n        }\n    };\n    /**\n     * utility function to mark element visible and add css class\n     *\n     * @returns void\n     */\n    AnimateOnScrollDirective.prototype.addAnimationClass = function () {\n        // mark this element visible, we won't remove the class after this\n        this.isVisible = true;\n        // use default for animate.css if no value provided\n        this.setClass(this.animationName);\n    };\n    /**\n     * utility function to add one or more css classes to element in DOM\n     *\n     * @param  {string} classes\n     * @returns void\n     */\n    AnimateOnScrollDirective.prototype.setClass = function (classes) {\n        for (var _i = 0, _a = classes.split(' '); _i < _a.length; _i++) {\n            var c = _a[_i];\n            this.renderer.addClass(this.elementRef.nativeElement, c);\n        }\n    };\n    /**\n     * get window height utility function\n     *\n     * @returns void\n     */\n    AnimateOnScrollDirective.prototype.getWinHeight = function () {\n        this.winHeight = typeof window !== 'undefined' ? window.innerHeight : 0;\n    };\n    /**\n     * get offsetTop value for element\n     *\n     * @returns void\n     */\n    AnimateOnScrollDirective.prototype.getOffsetTop = function () {\n        if (typeof this.elementRef.nativeElement.getBoundingClientRect === 'function') {\n            var viewportTop = this.elementRef.nativeElement.getBoundingClientRect().top;\n            var clientTop = this.elementRef.nativeElement.clientTop;\n            // get vertical position for selected element\n            this.offsetTop = viewportTop + this.scroll.pos - clientTop;\n        }\n        else {\n            this.offsetTop = 0;\n        }\n    };\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", String)\n    ], AnimateOnScrollDirective.prototype, \"animationName\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Number)\n    ], AnimateOnScrollDirective.prototype, \"offset\", void 0);\n    AnimateOnScrollDirective = __decorate([\n        core_1.Directive({\n            selector: '[animateOnScroll]'\n        }),\n        __metadata(\"design:paramtypes\", [core_1.ElementRef, core_1.Renderer2, scroll_service_1.ScrollService])\n    ], AnimateOnScrollDirective);\n    return AnimateOnScrollDirective;\n}());\nexports.AnimateOnScrollDirective = AnimateOnScrollDirective;\n"]}